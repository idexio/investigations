const fs = require('fs');
const BigNumber = require('bignumber.js');
BigNumber.config({ DECIMAL_PLACES: 40 });

const utils = require('./utils.js');

// wallet id => wallet address
const { lines: walletLines } = utils.readTsv('./inputs/wallets.tsv');
const walletLookup = utils.simpleMap(walletLines);
const walletReverseLookup = {};
for (const walletId in walletLookup) {
  walletReverseLookup[walletLookup[walletId].toLowerCase()] = parseInt(walletId);
}

// liquidity changes
const { 
  lines, 
  fieldMapping: fieldNameToIndex 
} = utils.readTsv('./inputs/engine-outputs.tsv');

// reverted transactions
const { 
  lines: reversionLines, 
  fieldMapping: reversionFieldNameToIndex 
} = utils.readTsv('./inputs/reversions.tsv');

// trading engine sequences of reverted transactions
const ignoredTradingEngineSequences = reversionLines.map(
  line => line.split("\t")[reversionFieldNameToIndex['tradingenginesequence']]
);

// transaction hashes
const { lines: transactionLines } = utils.readTsv('./inputs/transactions.tsv');
const transactionLookup = utils.simpleMap(transactionLines);

// on chain transfers
const { 
  lines: transferLines, 
  fieldMapping: transferFieldNameToIndex 
} = utils.readTsv('./inputs/on-chain-lp-transfers.tsv');

// keep track of when LP tokens were transferred
const transferLookups = {};
for (const transfer of transferLines) {
  const values = transfer.split("\t");
  const marketId = parseInt(values[transferFieldNameToIndex['marketid']])
  const lastSequence = parseInt(values[transferFieldNameToIndex['last liquidity sequence']]);
  const fromAddress = values[transferFieldNameToIndex['from']];
  const toAddress = values[transferFieldNameToIndex['to']];
  const transferQuantityInDecimalPips = values[transferFieldNameToIndex['quantity']];

  transferLookups[lastSequence] = {
    fromAddress,
    marketId,
    toAddress,
    transferQuantityInDecimalPips,
  }
}

// globals to collect our results
const allMarketsSeen = {};
const allWalletsSeen = {};
const walletLpTokenBalances = {};
const quoteMissingByWalletAndMarket = {};
let allTradingEngineSequences = {};

const quoteAnalysisHeaders = "type\ttxHash\tquoteAddedRemoved\tquoteExpected\tdifference";
let analysisBody = "";

for (const i in lines) {
  // load all the TSV columns
  const values = lines[i].split("\t");
  function loadByName(name) {
    return values[fieldNameToIndex[name]];
  }
  const marketId = parseInt(loadByName('market id'));
  const walletId = parseInt(loadByName('wallet id'));
  const type = loadByName('add/remove');
  const poolTokens = new BigNumber(loadByName('pool lp tokens before'));
  const baseReserve = new BigNumber(loadByName('pool base reserve before'));
  const quoteReserve = new BigNumber(loadByName('pool quote reserve before'));
  const baseAddedRemoved = new BigNumber(loadByName('base qty added/removed'));
  const quoteAddedRemoved = new BigNumber(loadByName('quote qty added/removed'));
  const lpTokensAddedRemoved = new BigNumber(loadByName('lp tokens added/removed'));
  const tradingEngineSequence = loadByName('output sequence number');

  // skip actions that were known reverted by the contract
  const foundIndex = ignoredTradingEngineSequences.indexOf(tradingEngineSequence);
  if (foundIndex > -1) {
    continue;
  }

  // tracking everything we've seen for complete output
  allWalletsSeen[walletId] = 1;
  allMarketsSeen[marketId] = 1;
  allTradingEngineSequences[tradingEngineSequence] = 1;

  // always update lp token balances
  utils.updateWalletLpTokenBalance(type, walletId, marketId, walletLpTokenBalances, lpTokensAddedRemoved);
  
  // known wallets with balance issues due to farming transfers
  if (walletLpTokenBalances[walletId][marketId].lt(0)) {
    throw new Error('Unexpected negative balance ' + i);
  }

  // sanity check that lp token balances add up
  let computedLpTokenBalance = new BigNumber(0);
  for (const walletId in walletLpTokenBalances) {
    for (const id in walletLpTokenBalances[walletId]) {
      if (parseInt(id) === marketId) {
        computedLpTokenBalance = computedLpTokenBalance.plus(walletLpTokenBalances[walletId][marketId]);
      }
    }
  }

  let expectedPoolTokensBefore = (type === 'add')
    ? poolTokens.plus(lpTokensAddedRemoved)
    : poolTokens.minus(lpTokensAddedRemoved);

  if (!computedLpTokenBalance.isEqualTo(expectedPoolTokensBefore)) {
    throw new Error("lp token pool size does not equal sum of the wallets");
  }

  // calculate to high precision the expected quote quantity of liquidity removals
  let expectedQuoteQuantity = quoteAddedRemoved;
  let amountCredited = BigNumber(0);
  if (type === 'remove') {
    expectedQuoteQuantity = quoteReserve
      .minus(
        baseReserve
          .minus(baseAddedRemoved)
          .multipliedBy(
            quoteReserve.dividedBy(baseReserve)
          )
      );
    const quoteDifference = quoteAddedRemoved.minus(expectedQuoteQuantity);

    // fractional differences of less than 1 is expected, due to whole number math
    // anything 1 or above is not expected
    if (quoteDifference.gte(1)) {
      amountCredited = quoteDifference;
      utils.assignMissingQuoteToWallets(walletLpTokenBalances, quoteMissingByWalletAndMarket, walletId, marketId, poolTokens, quoteDifference);
    }

    // there is no known issue in this direction, other than rounding
    if (quoteDifference.lte(-1)) {
      throw new Error(`Unexpected negative quote differential of ${quoteDifference} on line ${i+1}`);
    }      
  }

  // when on chain transfers happen between liquidity changes
  // we need to update the LP token balances on those wallets
  if (transferLookups[parseInt(tradingEngineSequence)]) {
    const {
      fromAddress,
      marketId: lpTokenMarketId,
      toAddress,
      transferQuantityInDecimalPips
    } = transferLookups[parseInt(tradingEngineSequence)];
    const walletIdFrom = walletReverseLookup[fromAddress.slice(2).toLowerCase()];
    const walletIdTo = walletReverseLookup[toAddress.slice(2).toLowerCase()];
    const quantityInPips = utils.decimalToPipInteger(transferQuantityInDecimalPips);
    walletLpTokenBalances[walletIdFrom][lpTokenMarketId] = walletLpTokenBalances[walletIdFrom][lpTokenMarketId].minus(quantityInPips);
    walletLpTokenBalances[walletIdTo] = walletLpTokenBalances[walletIdTo] || {};
    walletLpTokenBalances[walletIdTo][lpTokenMarketId] = walletLpTokenBalances[walletIdTo][lpTokenMarketId] || new BigNumber(0);
    walletLpTokenBalances[walletIdTo][lpTokenMarketId] = walletLpTokenBalances[walletIdTo][lpTokenMarketId].plus(quantityInPips);
    allWalletsSeen[walletIdFrom] = 1;
    allWalletsSeen[walletIdTo] = 1;
  }

  // write the results of this iteration of the analysis
  const txHash = transactionLookup[tradingEngineSequence];
  analysisBody += `${type}\t${txHash}\t${quoteAddedRemoved}\t${expectedQuoteQuantity.toFixed(10)}\t${amountCredited.toFixed(10)}\n`;
}

// the data is sparse, create a value for every wallet/market pair
for (const walletId in allWalletsSeen) {
  quoteMissingByWalletAndMarket[walletId] = quoteMissingByWalletAndMarket[walletId] || {};
  for (const marketId in allMarketsSeen) {
    quoteMissingByWalletAndMarket[walletId][marketId] = quoteMissingByWalletAndMarket[walletId][marketId] || new BigNumber(0);
  }
}

// convert to array form for sorting, and remove the decimals
const arrayForm = [];
for (const walletId in allWalletsSeen) {
  for (const marketId in allMarketsSeen) {
    arrayForm.push([
      parseInt(walletId), 
      parseInt(marketId), 
      quoteMissingByWalletAndMarket[walletId][marketId].toFixed(0),
    ]);
  }
}

// raw output quantities
const ethMarkets = [6,7,8,9,10,11,12,13,14];
const usdcMarkets = [3,4,5,16,17,18,19];
const ethOwedByWallet = {};
const usdcOwedByWallet = {};

const headers = 'address\tmarketId\tquantity';
let body = '';
arrayForm.forEach(v => {
  const walletId = v[0];
  const marketId = v[1];
  const amountOwed = parseInt(v[2]);

  let walletAddress = walletLookup[walletId];
  if (!walletAddress) {
    throw new Error(`Unexpected missing wallet address (id = ${walletId}`);
  }
  body += `0x${walletAddress}\t${marketId}\t${amountOwed}\n`;

  if (ethMarkets.indexOf(marketId) > -1) {
    ethOwedByWallet[walletAddress] = ethOwedByWallet[walletAddress] 
      ? ethOwedByWallet[walletAddress] + amountOwed
      : amountOwed;
  } else if (usdcMarkets.indexOf(marketId) > -1) {
    usdcOwedByWallet[walletAddress] = usdcOwedByWallet[walletAddress] 
      ? usdcOwedByWallet[walletAddress] + amountOwed
      : amountOwed;
  } else {
    throw new Error(`Unrecognized market ${marketId}`);
  }
})

const ethHeaders = 'symbol\twallet_address\tquantity';
let ethBody = '';
let ethTotal = 0;
let ethCount = 0;
for (const address in ethOwedByWallet) {
  if (ethOwedByWallet[address] !== 0) {
    ethBody += `ETH\t0x${address}\t${ethOwedByWallet[address]}\n`;
    if (ethOwedByWallet[address] > 0) {
      ethTotal += ethOwedByWallet[address];
      ethCount++;
    }
  }
}

const usdcHeaders = ethHeaders;
let usdcBody = '';
let usdcTotal = 0;
let usdcCount = 0;
for (const address in ethOwedByWallet) {
  if (usdcOwedByWallet[address] !== 0) {
    usdcBody += `USDC\t0x${address}\t${usdcOwedByWallet[address]}\n`;
    if (usdcOwedByWallet[address] > 0) {
      usdcTotal += usdcOwedByWallet[address];
      usdcCount++;
    }
  }
}

console.log(`${ethTotal} ETH owed to ${ethCount} wallets`);
console.log(`${usdcTotal} USDC owed to ${usdcCount} wallets`);

fs.writeFileSync('./outputs/analysis.tsv', `${quoteAnalysisHeaders}\n${analysisBody}`);
fs.writeFileSync('./outputs/owed_by_wallet_market.tsv', `${headers}\n${body}`);
fs.writeFileSync('./outputs/eth_owed_by_wallet.tsv', `${ethHeaders}\n${ethBody}`);
fs.writeFileSync('./outputs/usdc_owed_by_wallet.tsv', `${usdcHeaders}\n${usdcBody}`);

// fs.writeFileSync('./temp/wallet_ids.json', JSON.stringify(Object.keys(walletLpTokenBalances)));
// fs.writeFileSync('./temp/sequences.json', JSON.stringify(Object.keys(allTradingEngineSequences)));